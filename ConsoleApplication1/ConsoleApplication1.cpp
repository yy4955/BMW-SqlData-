// ConsoleApplication1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include "MyByteOperation.h"
#include "BMW_Sql_Deserialization.h"
#include "ExpressionCalculate.h"
//------------------------------------------------------------
//-----------  BMW原厂诊断软件SqlData提取和计算功能还原   -----------
//------        Date： 20200508          ------
//目前只解析了“&”，“！”，“|”，“Date”的逻辑运算
//------------------------------------------------------------
unsigned char hexData[129] = {
	0x01, 0x01, 0x00, 0x00, 0x00, 0x02, 0x07, 0x00, 0x00, 0x00, 0x11, 0x8B, 0xEB, 0x29, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x0B, 0x8D, 0xCB, 0x8C, 0x0F, 0x00, 0x00, 0x00, 0x11, 0x8B, 0xEB, 0x29, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x8B, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x00, 0x00, 0x11, 0x8B, 0xEB, 0x29,
	0x03, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x09, 0x2A, 0x03, 0x00, 0x00, 0x00, 0x00, 0x11, 0x8B, 0xEB,
	0x29, 0x03, 0x00, 0x00, 0x00, 0x00, 0xEC, 0x39, 0xAA, 0xA3, 0x30, 0x12, 0x00, 0x00, 0x11, 0x8B,
	0xEB, 0x29, 0x03, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xF8, 0x29, 0x03, 0x00, 0x00, 0x00, 0x00, 0x11,
	0x8B, 0xEB, 0x29, 0x03, 0x00, 0x00, 0x00, 0x00, 0x8B, 0xEF, 0x29, 0x03, 0x00, 0x00, 0x00, 0x00,
	0x11, 0x8B, 0xEB, 0x29, 0x03, 0x00, 0x00, 0x00, 0x00, 0x96, 0x3D, 0x23, 0xA5, 0x30, 0x12, 0x00,
	0x00
};

/*
01 01000000 02 07000000 11 8BEB2903000000000 B8DCB8C0F000000 11 8BEB2903000000008B002A0300000000 11 8BEB2903000000000B092A0300000000 11 8BEB290300000000EC39AAA330120000 11\
		8BEB2903000000000BF8290300000000 11 8BEB2903000000008BEF290300000000 11 8BEB290300000000963D23A530120000"
[0]逻辑标识符预判  
[1-4]外循环次数
[5]逻辑标识符识别
[6-9]内循环次数
[10]逻辑标识符识别
[11-27]ClassID 8位  +  valueID 8位
01 03000000 11 8BEB2903000000000 B092A0300000000 03 11 8B112A0300000000 8BF02C0300000000 02 02000000 11 8B6B36250A0000000 B7B36250A000000 11 8B6B36250A000000 8B8436250A000000
(Marke=BMW PKW [53078923=53086475] AND NOT E-Bezeichnung=E89 [53088651=53276811] AND (Produktlinie=PL2 [43573996427=43574000395] OR Produktlinie=PL6-alt [43573996427=43574002827]))
0103000000118BEB2903000000000B092A030000000003118B112A03000000008BF02C03000000000202000000118B6B36250A0000000B7B36250A000000118B6B36250A0000008B8436250A000000

  IStufeX:
 rule id: 5357089547 rule: (((Marke=BMW PKW [53078923=53086475] OR Marke=MINI PKW [53078923=53082123] OR Marke=ROLLS-ROYCE PKW [53078923=53079947]) AND IStufeX: HO-I-Stufe GREATER_EQUAL 'F001-10-09-500' [40564650763] AND IStufeX: HO-I-Stufe LESS_EQUAL 'F001-11-03-500' [53945038091]) OR ((Marke=BMW PKW [53078923=53086475] OR Marke=MINI PKW [53078923=53082123] OR Marke=ROLLS-ROYCE PKW [53078923=53079947]) AND IStufeX: HO-I-Stufe GREATER_EQUAL 'F010-10-09-500' [40564717195] AND IStufeX: HO-I-Stufe LESS_EQUAL 'F010-11-03-500' [40564736907]) OR ((Marke=BMW PKW [53078923=53086475] OR Marke=MINI PKW [53078923=53082123] OR Marke=ROLLS-ROYCE PKW [53078923=53079947]) AND NOT Baureihenverbund=F001 [45414283=13608927115] AND NOT Baureihenverbund=F010 [45414283=13609012363]))
 
020300000001030000000203000000118BEB2903000000000B092A0300000000118BEB2903000000000BF8290300000000118BEB2903000000008BEF2903000000001403000B73D771090000001405000BF55F8F0C00000001030000000203000000118BEB2903000000000B092A0300000000118BEB2903000000000BF8290300000000118BEB2903000000008BEF2903000000001403008B76D871090000001405008BC3D8710900000001030000000203000000118BEB2903000000000B092A0300000000118BEB2903000000000BF8290300000000118BEB2903000000008BEF29030000000003118BF7B402000000008BBF272B0300000003118BF7B402000000008B0C292B03000000

date:
 rule id: 1033674251 rule: ((Marke=BMW PKW [53078923=53086475] AND E-Bezeichnung=E68 [53088651=53094027] AND EcuClique=1037900171 AND Baustand >= 200703) OR (Marke=BMW PKW [53078923=53086475] AND (E-Bezeichnung=E60 [53088651=53202827] OR E-Bezeichnung=E61 [53088651=53268107] OR E-Bezeichnung=E63 [53088651=53259403] OR E-Bezeichnung=E64 [53088651=53263755] OR E-Bezeichnung=E65 [53088651=53218059] OR E-Bezeichnung=E66 [53088651=53296395] OR E-Bezeichnung=E67 [53088651=53287691] OR E-Bezeichnung=E81 [53088651=53089675] OR E-Bezeichnung=E82 [53088651=53200651] OR E-Bezeichnung=E84 [53088651=53233291] OR E-Bezeichnung=E87 [53088651=53222411] OR E-Bezeichnung=E88 [53088651=53270283] OR E-Bezeichnung=E90 [53088651=53137547] OR E-Bezeichnung=E91 [53088651=53228939] OR E-Bezeichnung=E92 [53088651=53146251] OR E-Bezeichnung=E93 [53088651=53107083]) AND (EcuClique=1037897611 OR EcuClique=1037900171) AND Baustand >= 200609))

02 02000000 01 04000000 11 8BEB2903000000000 B092A0300000000 11 8B112A0300000000 8B262A0300000000 0C 8B19DD3D00000000 04 03 FF0F030000000000 01 04000000 118BEB2903000000000B092A03000000000210000000118B112A03000000008BCF2B0300000000118B112A03000000008BCE2C0300000000118B112A03000000008BAC2C0300000000118B112A03000000008BBD2C0300000000118B112A03000000000B0B2C0300000000118B112A03000000000B3D2D0300000000118B112A03000000000B1B2D0300000000118B112A03000000008B152A0300000000118B112A03000000000BC72B0300000000118B112A03000000008B462C0300000000118B112A03000000000B1C2C0300000000118B112A03000000000BD72C0300000000118B112A03000000008BD02A0300000000118B112A03000000008B352C0300000000118B112A03000000008BF22A0300000000118B112A03000000008B592A030000000002020000000C8B0FDD3D000000000C8B19DD3D00000000 04 03 A10F0300 00 00 00 00
*/

void test()
{
	const char *strTest = "CED2CAC7B8F6B4F3D0DCC3A8";
	auto charVec = hexToBin(strTest);
	for (auto element : charVec) {
		std::cout << element;
	}
	std::cout << std::endl;
	auto strHex = binToHex(charVec.data(), charVec.size());
	std::cout << strHex << std::endl;
	//vector 转string
	std::string stBuf;
	stBuf.assign(strHex.begin(), strHex.end());
	system("pause");
}

//布尔运算测试
void booltest(std::string str)
{
	//([true] & ( ! [true]) & ([true] | [true]))
	//([53078923=53086475] & ( ! [53088651=53276811]) & ([43573996427=43574000395] | [43573996427=43574002827]))

	//初始化运算类型switch string
	Initialize();
	bool b = splitRPN(str);
	std::cout << str << std::boolalpha << b <<std::endl;
}

//sql解析测试
void test(std::stringstream &istream)
{
	//std::stringstream  istream;
	std::stringstream  istreamA;
	std::string strSql;
	std::string str = "";
	istream >> str;
	auto vectorHex = hexToBin(str);
	str = "";
	str.clear();	
	str.assign(vectorHex.begin(), vectorHex.end());
	istreamA << str;
	//debug

	SwitchLogType(istreamA, strSql);

	//写文件
	std::ofstream outfile;
	outfile.open("Sql解析.txt", std::ios::binary | std::ios::app);
	if (!outfile.is_open())
	{
		printf("%s\r\n",strerror(errno));
	}
	outfile << strSql << "\r\n";
	outfile.close();
}

int main()
{
	G_mapHash.insert(std::make_pair("53078923", 53086475));
	G_mapHash.insert(std::make_pair("53088651", 53094027));
	G_mapHash.insert(std::make_pair("ECUCLIQUE", 1037900171));
	G_mapHash.insert(std::make_pair("DATE", 200703));
	G_mapHash.insert(std::make_pair("53078923", 53086475));

	G_mapHash.insert(std::make_pair("53088651", 53202827));

	G_mapHash.insert(std::make_pair("53088651", 53268107));
	G_mapHash.insert(std::make_pair("53088651", 53259403));

	G_mapHash.insert(std::make_pair("53088651", 53263755));
	G_mapHash.insert(std::make_pair("53088651", 53218059));

	G_mapHash.insert(std::make_pair("53088651", 53296395));
	G_mapHash.insert(std::make_pair("53088651", 53287691));
	G_mapHash.insert(std::make_pair("53088651", 53089675));
	G_mapHash.insert(std::make_pair("53088651", 53086475));
	G_mapHash.insert(std::make_pair("53078923", 53086475));
	G_mapHash.insert(std::make_pair("DATE", 200609));
	//bool b = (([53078923 = 53086475] AND [53088651 = 53094027] AND [ECUCLIQUE = 1037900171] AND [DATE - GREATER_EQUAL - 200703]) OR ([53078923 = 53086475] AND ([53088651 = 53202827] OR [53088651 = 53268107] OR [53088651 = 53259403] OR [53088651 = 53263755] OR [53088651 = 53218059] OR [53088651 = 53296395] OR [53088651 = 53287691] OR [53088651 = 53089675] OR [53088651 = 53200651] OR [53088651 = 53233291] OR [53088651 = 53222411] OR [53088651 = 53270283] OR [53088651 = 53137547] OR [53088651 = 53228939] OR [53088651 = 53146251] OR [53088651 = 53107083]) AND ([ECUCLIQUE = 1037897611] OR [ECUCLIQUE = 1037900171]) AND[DATE - GREATER_EQUAL - 200609]));

	//std::cout << "(([53078923=53086475] AND [53088651=53094027] AND [ ECUCLIQUE = 1037900171] AND [ DATE - GREATER_EQUAL - 200703]) OR ([53078923=53086475] AND ([53088651=53202827] OR [53088651=53268107] OR [53088651=53259403] OR [53088651=53263755] OR [53088651=53218059] OR [53088651=53296395] OR [53088651=53287691] OR [53088651=53089675] OR [53088651=53200651] OR [53088651=53233291] OR [53088651=53222411] OR [53088651=53270283] OR [53088651=53137547] OR [53088651=53228939] OR [53088651=53146251] OR [53088651=53107083]) AND ([ ECUCLIQUE = 1037897611] OR [ ECUCLIQUE = 1037900171]) AND [ DATE - GREATER_EQUAL - 200609]))= " << std::boolalpha << b << std::endl;

	//date:  02020000000104000000118BEB2903000000000B092A0300000000118B112A03000000008B262A03000000000C8B19DD3D000000000403FF0F0300000000000104000000118BEB2903000000000B092A03000000000210000000118B112A03000000008BCF2B0300000000118B112A03000000008BCE2C0300000000118B112A03000000008BAC2C0300000000118B112A03000000008BBD2C0300000000118B112A03000000000B0B2C0300000000118B112A03000000000B3D2D0300000000118B112A03000000000B1B2D0300000000118B112A03000000008B152A0300000000118B112A03000000000BC72B0300000000118B112A03000000008B462C0300000000118B112A03000000000B1C2C0300000000118B112A03000000000BD72C0300000000118B112A03000000008BD02A0300000000118B112A03000000008B352C0300000000118B112A03000000008BF22A0300000000118B112A03000000008B592A030000000002020000000C8B0FDD3D000000000C8B19DD3D000000000403A10F030000000000
	//02020000000102000000118BEB2903000000000B092A03000000000204000000118B112A03000000000B0B2C0300000000118B112A03000000000B3D2D0300000000118B112A03000000000B1B2D0300000000118B112A03000000008B262A03000000000102000000118BEB2903000000008BEF2903000000000203000000118B112A03000000000B512A0300000000118B112A03000000000B952A0300000000118B112A03000000000B2C2D0300000000
	std::stringstream  istream("02020000000104000000118BEB2903000000000B092A0300000000118B112A03000000008B262A03000000000C8B19DD3D000000000403FF0F0300000000000104000000118BEB2903000000000B092A03000000000210000000118B112A03000000008BCF2B0300000000118B112A03000000008BCE2C0300000000118B112A03000000008BAC2C0300000000118B112A03000000008BBD2C0300000000118B112A03000000000B0B2C0300000000118B112A03000000000B3D2D0300000000118B112A03000000000B1B2D0300000000118B112A03000000008B152A0300000000118B112A03000000000BC72B0300000000118B112A03000000008B462C0300000000118B112A03000000000B1C2C0300000000118B112A03000000000BD72C0300000000118B112A03000000008BD02A0300000000118B112A03000000008B352C0300000000118B112A03000000008BF22A0300000000118B112A03000000008B592A030000000002020000000C8B0FDD3D000000000C8B19DD3D000000000403A10F030000000000");
	//test(istream);
	//booltest("(([53078923=53086475] AND ([53088651=53218059] OR [53088651=53296395] OR [53088651=53287691] OR [53088651=53094027])) OR ([53078923=53079947] AND ([53088651=53104907] OR [53088651=53122315] OR [53088651=53292043])))");
	bool b =((true & true & true & true) | (true & (false | false | false | false | false | false | false | false | false | false | false | false | false | false | false | false) & (false | true) & true));
	std::cout << "test:" << std::boolalpha << b << std::endl;


	booltest("(([53078923=53086475] & [53088651=53094027] & [ ECUCLIQUE = 1037900171] & [ DATE - GREATER_EQUAL - 200703]) | ([53078923=53086475] & ([53088651=53202827] | [53088651=53268107] | [53088651=53259403] | [53088651=53263755] | [53088651=53218059] | [53088651=53296395] | [53088651=53287691] | [53088651=53089675] | [53088651=53200651] | [53088651=53233291] | [53088651=53222411] | [53088651=53270283] | [53088651=53137547] | [53088651=53228939] | [53088651=53146251] | [53088651=53107083]) & ([ ECUCLIQUE = 1037897611] | [ ECUCLIQUE = 1037900171]) & [ DATE - GREATER_EQUAL - 200609]))");
	std::string strFile;
	std::ifstream ifile;
	if (ifile.is_open())
	{
		printf("%s\r\n", strerror(errno));
		getline(ifile, strFile);
	}
	booltest("((([53078923=53086475] OR [53078923=53082123] OR [53078923=53079947])) AND (([53078923=53086475] OR [53078923=53082123] OR [53078923=53079947])) AND (([53078923=53086475] AND [53078923=53082123] AND [53078923=53079947]) AND ( NOT [45414283=13608927115]) AND ( NOT [45414283=13609012363])))");

}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门提示: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
